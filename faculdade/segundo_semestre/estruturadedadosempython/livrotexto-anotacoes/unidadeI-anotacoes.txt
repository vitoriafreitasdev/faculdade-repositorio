unidadeI-anotacoes

1 INTRODUÇÃO A ALGORITMOS, LINGUAGEM PYTHON E ESTRUTURAS DE DADOS

Python => clareza e simplicidade

-algoritmo => sequência finita de passos bem definidos, projetados
para resolver um problema ou executar uma tarefa específica. 
desde de operações
matemáticas simples, como somar dois números, até processos mais complexos, como ordenar grandes
volumes de dados ou realizar buscas em estruturas de informação

-estruturas de dados => maneiras de organizar, armazenar e manipular os dados necessários para que algoritmos sejam executados
de maneira eficiente.

-relevância dos algoritmos => capacidade de automatizar processos, reduzindo
o esforço humano necessário para realizar tarefas repetitivas ou complicadas

-desempenham papel em todos os campos da tecnologia moderna, desde o aprendizado de máquina e a
inteligência artificial até a gestão de bancos de dados e os sistemas operacionais

-escolha de algoritmos => significar a diferença entre uma aplicação funcional e eficiente e outra que consome
recursos desnecessários ou apresenta baixo desempenho.

-Estruturas de dados: fornecer os meios para que informações
sejam organizadas e acessadas de maneira eficiente. Com a correta operações( busca, inserção, remoção ou ordenação de dados) podem ser realizadas com maior rapidez, com economia de tempo e recursos computacionais.

- Big‑O  => instrumentos mais utilizados para descrever
a complexidade de algoritmos, pois oferece uma forma padronizada de expressar o comportamento
de uma solução conforme o tamanho do conjunto de dados aumenta.
essencial: aplicações que lidam com grandes volumes de dados, nos quais pequenas diferenças
na eficiência podem ter impactos significativos.

- Big O => a ferramenta essencial para descrever o comportamento
de algoritmos em termos de complexidade de tempo e espaço. Usa símbolos matemáticos
para expressar como o desempenho de um algoritmo escala em relação ao tamanho do conjunto de
entrada. O(1) indica que o tempo de execução é constante, independentemente do tamanho
da entrada
O(n), por outro lado, indica que o tempo de execução aumenta linearmente com
o tamanho da entrada, como em busca linear

 Também chamada de notação assintótica ou notação de ordem de grandeza, é utilizada para
descrever o comportamento de algoritmos conforme o tamanho da entrada cresce.
 Essa notação permite representar a taxa de crescimento do tempo de execução ou do uso
de memória, independentemente de detalhes específicos de implementação ou de hardware.

comportamento assintótico refere-se à forma como uma função cresce quando seu
parâmetro, como o tamanho da entrada de um algoritmo, tende ao infinito.
 No contexto dos algoritmos, essa análise avalia como o tempo de execução ou o uso de
memória se modifica à medida que n, o tamanho da entrada, se eleva consideravelmente.

#Conceitos fundamentais: o que são algoritmos e estruturas de dados e
como utilizar a linguagem Python

-algoritmo =>  comparado a uma receita de cozinha,  descreve, passo a passo, o que deve ser feito para preparar um prato, um algoritmo apresenta
uma sequência clara e ordenada de instruções para resolver um problema ou realizar uma tarefa.  pode ser encontrado em diversas situações diárias.
exemplo, quando alguém explica como chegar a um local desconhecido, descrevendo o caminho em
etapas, está, na prática, criando um algoritmo. 

- na computação =>  é um conjunto de instruções que um computador pode
seguir para realizar uma operação específica

 maneira mais técnica, um algoritmo pode ser definido como uma sequência finita, ordenada e
bem definida de instruções que, ao serem executadas, resolvem um problema específico ou realizam
uma tarefa. 
fundamenta‑se em princípios de lógica matemática e de estruturação computaciona

-algoritmo deve atender a certas propriedades

• Finitude: um algoritmo deve sempre terminar após um número finito de passos. Ele não pode
continuar indefinidamente, a menos que seja projetado especificamente para isso
• Precisão: cada passo de um algoritmo precisa ser bem definido, ou seja, sem ambiguidades.
O computador (ou o executor humano) deve ser capaz de compreender e executar cada etapa
exatamente como descrita.
• Entrada: um algoritmo recebe zero ou mais entradas, que são os dados iniciais necessários para
começar o processamento.
• Saída: um algoritmo produz uma ou mais saídas, que são os resultados esperados após a execução
das instruções.
• Eficácia: cada instrução do algoritmo deve ser suficientemente básica para que possa ser
executada em tempo finito, utilizando recursos computacionais disponíveis.

 Ele é geralmente descrito em forma de
pseudocódigo ou de fluxograma antes de ser traduzido para código executável, o que facilita sua
compreensão e sua análise.

Para ilustrar, considere o problema clássico de determinar se um número inteiro é par ou ímpar.
Um algoritmo técnico para resolver esse problema pode ser descrito assim como segue.
• Receber um número inteiro como entrada.
• Dividir o número por 2 e calcular o resto (operação de módulo).
• Se o resto for igual a 0, o número será par.
• Caso contrário, o número será ímpar.
• Retornar o resultado (par ou ímpar).
O pseudocódigo desse algoritmo seria como vemos a seguir.
Entrada: número inteiro `n`
Se (n % 2 == 0):
Retornar “Par”
Senão:
Retornar “Ímpar”

análise mais técnica também inclui a eficiência do algoritmo, que é avaliada em termos de sua
complexidade de tempo e espaço.

exemplo anterior, a complexidade de tempo é O(1), porque
a operação de módulo é executada em tempo constante, independentemente do tamanho da entrada. 
 é verdade que, em uma execução prática, verificar se
o número 2 é par será ligeiramente mais rápido do que verificar se o número 10 bilhões é par. Entretanto,
essa diferença, no contexto da complexidade computacional, não é relevante ou significativa o suficiente
para alterar a classificação.

complexidade O(1) não significa que o algoritmo levará exatamente o mesmo número de
nanossegundos ou ciclos do processador independentemente do tamanho exato da entrada. Em vez
disso, é que o número de passos fundamentais do algoritmo não aumenta conforme
a entrada cresce. É o número de operações básicas, como somar, dividir ou testar uma condição simples,
que permanece constante. 


-Python é uma linguagem de programação de alto nível
Criada por Guido van Rossum na década de 1990, Python é usada em diversas áreas, como
desenvolvimento web, ciência de dados, inteligência artificial e automação de tarefas.
 ela é interpretada, o que significa que seu código não precisa ser
compilado antes de ser executado

-Essa flexibilidade caracteriza a tipagem
dinâmica: não é necessário declarar antecipadamente o tipo de dado, pois Python identifica
automaticamente se a variável conterá números, textos, listas ou outros objetos.

o conceito de função, que é um bloco de código nomeado,
responsável por encapsular operações reutilizáveis e separar responsabilidades

síntese, variáveis fornecem meios de nomear e manipular dados ao longo da execução,
enquanto funções promovem a organização do código em módulos concisos e reutilizáveis.

laço while repete um bloco
enquanto uma condição permanecer verdadeira. No trecho a seguir, o código solicita ao usuário que
digite a palavra sair para interromper o processo:

comando = “”
while comando != “sair”:
	comando = input(“Digite ‘sair’ para encerrar: “)
print(“Programa encerrado”)

A observância rigorosa da indentação é imprescindível: qualquer desalinhamento gera erro de
sintaxe, impedindo a execução do programa. Em caso de recuos inconsistentes, Python sinaliza
IndentationError, indicando que foi encontrada uma posição inesperada. 


--  generator expression é um recurso da Python que permite
criar coleções de maneira concisa e eficiente. Seu uso evita a necessidade
de laços explícitos (for) e torna o código mais legível. Em vez de criar e
armazenar a lista inteira na memória, ele gera os elementos sob demanda,
economizando espaço. Por exemplo, ao invés de escrever um laço for
tradicional para criar uma lista de quadrados dos números de 1 a 10,
podemos usar o generator expression:

 expressão geradora é que os valores não são armazenados
em uma lista, mas sim calculados conforme necessário. Essa característica
torna o método muito mais eficiente em termos de uso de memória, 


 conceitos de list comprehension e generator expression são recursos
do Python que evitam a necessidade de laços explícitos (for) e tornam o
código mais legível. No entanto, há diferenças fundamentais entre eles,
principalmente no modo como armazenam e processam os dados. A list
comprehension é uma maneira compacta de criar listas a partir de uma
sequência de elementos, aplicando transformações e filtragens diretamente
na declaração da lista. Sua principal característica é que ela retorna
36
Unidade I
uma nova lista contendo todos os elementos gerados pela expressão
interna. Como o resultado é armazenado diretamente na memória

JSON (JavaScript Object Notation) é um formato de armazenamento e troca de dados que organiza
informações de maneira estruturada e de fácil leitura, tanto para humanos quanto para computadores. 

utiliza uma estrutura baseada em pares chave‑valor, semelhante a dicionários em Python ou objetos
em JavaScript,

API (Interface de Programação de Aplicações) é um conjunto de
regras e definições que permite que diferentes sistemas e programas se
comuniquem entre si

#1.2 Análise de complexidade: introdução à notação Big‑O e à análise
de eficiência

auxilia na tomada de decisões sobre qual estratégia de implementação é mais adequada
para problemas que demandam alto desempenho ou lidam com grandes quantidades de dados


o comportamento assintótico refere‑se à forma como uma função se comporta quando seu
parâmetro tende ao infinito.


algoritmos => deseja‑se saber como o tempo de execução
(ou uso de memória) varia em função do tamanho da entrada, denotado com frequência por 𝑛.

interessa mais a taxa de crescimento desses recursos à medida que 𝑛 aumenta

o Big‑O é a forma mais amplamente utilizada para descrever limites superiores de crescimento

exemplo: algoritmo 𝐴 tem complexidade 𝑂(𝑓(𝑛)) significa que, para entradas
suficientemente grandes, o tempo de execução de 𝐴 não cresce mais rápido do que uma função
constante vezes 𝑓(𝑛)

 Se a sala tem 10 alunos, você faz 10 verificações; se tem 100, faz 100
verificações e assim por diante. Esse é um exemplo de comportamento linear: conforme o número de
alunos 𝑛 cresce, o trabalho sobe de forma proporcional e por isso dizemos que a tarefa está em 𝑂(𝑛).
Usando a definição de Big‑O:
• 𝐴(𝑛) é o tempo para conferir todas as assinaturas.
• 𝑓(𝑛) pode ser simplesmente n

execução constante, o que significa que não sofrem variação
perceptível à medida que o tamanho da entrada cresce. São classificados como 0(1). Um exemplo típico
desse comportamento é o acesso a um elemento específico de um array (ou lista) por índice: teoricamente,
considera‑se que buscar o valor em uma posição já conhecida tem custo fixo, independentemente de
quantos elementos existem ao todo.

m algoritmos cujo tempo de execução é logarítmico, especialmente quando
o tamanho do problema é reduzido pela metade (ou por um fator constante) a cada passo. A busca
binária em uma lista ordenada é um exemplo clássico: a cada comparação, descarta‑se metade dos
elementos, o que faz a quantidade de passos crescer de forma proporcional a log  


 𝑂(𝑛 log 𝑛), costuma-se dizer que ele é
linear‑logarítmico (Merge Sort
e Quick Sort (na média).)


𝑂(𝑛2). Isso é frequente em
algoritmos que utilizam laços aninhados, como Bubble Sort e Insertion Sort, em que para cada elemento
da lista é preciso percorrer novamente toda a lista (ou uma fração significativa dela).


𝑂(𝑛3
), que surge em algoritmos
com tripla aninhada de laços, por exemplo, em métodos básicos de multiplicação de matrizes. Já 𝑂(2𝑛)
é frequente em algoritmos de força bruta, que testam todas as combinações possíveis para resolver um
problema de decisão

 𝑂(𝑛!)  => caixeiro viajante


No uso prático, nem sempre o algoritmo assintoticamente mais rápido é o mais indicado. Para
entradas pequenas, métodos 𝑂(𝑛2
) podem superar outros 𝑂(𝑛 log 𝑛) devido a fatores como constantes
menores de tempo ou melhor uso de cache. É por isso que engenheiros e cientistas da computação
realizam não apenas análise teórica, mas testes empíricos (microbenchmarks) para embasar suas
decisões. 


Big‑O é uma forma de medir e comparar a eficiência de algoritmos ao analisar
como o tempo de execução (ou uso de memória) cresce conforme aumenta o tamanho da entrada

2 ESTRUTURAS DE DADOS LINEARES

organizam os elementos em
uma sequência ordenada, na qual cada item possui um predecessor e um sucessor (exceto o primeiro e
o último). 
elementos são acessados de maneira sequencial, respeitando
a ordem na qual foram inseridos. Diferentemente das estruturas não lineares, como árvores e grafos,
que permitem múltiplas conexões entre os elementos, as estruturas lineares mantêm uma relação direta
entre os itens, o que facilita a manipulação e o processamento dos dados.


permite a realização de operações como pesquisa, inserção e remoção
com base na posição dos elementos. Em listas e arrays, por exemplo, o acesso a um item pode ser feito
por meio de um índice numérico, garantindo eficiência quando a posição do elemento é conhecida.
No entanto, a inserção e a remoção em determinadas posições podem exigir deslocamentos de outros
elementos, o que impacta o desempenho dependendo da implementação utilizada.


pilhas e filas são classificadas como estruturas lineares porque
seguem uma ordem específica de inserção e remoção.

LIFO (Last In, First Out) para pilhas e FIFO (First In, First Out) para listas

Quando há necessidade de relacionamentos hierárquicos entre elementos
ou múltiplas conexões, como acontece em árvores e grafos, as estruturas não lineares tornam‑se mais
apropriadas. Contudo, para armazenar e processar dados de forma sequencial, as estruturas lineares
continuam sendo uma das abordagens mais eficientes e amplamente utilizadas na computação.

Listas são adequadas para armazenamento genérico de elementos
heterogêneos, enquanto arrays são preferíveis para manipulação eficiente de dados homogêneos.
Pilhas são úteis em problemas que exigem rastreamento de estados anteriores, como a execução de
chamadas recursivas e o gerenciamento de histórico de navegação. Filas, por sua vez, são empregadas
em sistemas que necessitam de processamento sequencial de requisições, como filas de impressão
e algoritmos de escalonamento

2.1 Listas e arrays: manipulação, pesquisa, inserção e remoção

Função Descrição
datetime.now() Retorna a data e a hora atuais do sistema
timedelta(seconds=n) Cria um intervalo de ‘n’ segundos, utilizado para manipulação de datas e horários
sum(iterável) Calcula a soma dos elementos de um iterável (como listas e dicionários)
for elemento in iterável Itera sobre os elementos de um iterável, executando um bloco de código para cada item
dicionario[chave] Acessa o valor correspondente a uma chave dentro de um dicionário
dicionario[‘chave’] = valor Atribui um valor a uma chave específica dentro de um dicionário

range(início, fim)
Gera uma sequência de números inteiros, incluindo o valor inicial e excluindo o valor final.
No código, é usado implicitamente no for i in range(1, qtd_registros + 1)
para gerar os identificadores dos registros
random.choice(sequência) Retorna um elemento aleatório de uma sequência, como uma lista. No código, é usado
para escolher aleatoriamente um id_dispositivo
registros[-1] Acessa o último elemento da lista registros
timedelta(minutes=n) Cria um intervalo ‘n’ minutos, utilizado para cálculos com datas e horas. Já havia sido usada
com segundos, mas aqui há o uso específico de minutos



np.dtype([...]) - Define a estrutura de um tipo composto para arrays NumPy, permitindo armazenar
diferentes campos (como um registro com timestamp, IP, usuário e status) em um único array
estruturado


np.empty(tamanho, dtype=...) - Cria um array não inicializado (com valores arbitrários) com o número de elementos e tipo
especificado, usado para otimizar desempenho quando os valores serão preenchidos logo em seguida

np.array([...]) Cria um array NumPy a partir de uma lista ou tupla de dados. No código, é usado tanto para
listas de valores quanto para construção de um novo registro

np.random.choice(array) Escolhe aleatoriamente um elemento de um array. Pode incluir o parâmetro p=... para
atribuir probabilidades aos elementos

np.datetime64(data, unidade) Converte um valor de tempo (como um datetime) para o tipo datetime64 do NumPy,
usado para compatibilidade com arrays estruturados e operações vetoriais
np.timedelta64(valor, unidade) Representa uma diferença de tempo no formato do NumPy, usado para realizar somas com
datas em arrays

array[‘campo’] Acessa os valores de um campo específico em um array estruturado. Por exemplo,
registros[‘ip’] retorna todos os IPs registrados

np.unique(array, return_
counts=True)
Retorna os elementos únicos do array e, se return_counts=True, também a contagem
de cada elemento. No código, é usado para contar falhas por IP

np.append(array, novo_
elemento)

Retorna um novo array com o elemento adicionado ao final. No código, é
usado para inserir um novo log no array de registros

.astype(tipo)
Converte o tipo de dados de um array ou campo. No código, é utilizado para converter
datetime64 do NumPy para objetos datetime do Python padrão, a fim de imprimir de
forma legível


Latência refere‑se ao intervalo entre o momento em que um dado
entra na estrutura e o instante em que se obtém resposta ou se processa
a próxima etapa. Em robótica, latência reduzida garante reações rápidas;
em atendimento, evita demora perceptível ao cliente; na blockchain,
minimiza  o tempo necessário para que uma transação seja incluída em
bloco. O controle de latência envolve escolha da estrutura, afinação de
algoritmos e otimização de hardware subjacente.


O termo LIDAR deriva de “Light Detection and Ranging”, ou “Detecção
e Medição por Luz”, e refere‑se a uma tecnologia que utiliza pulsos de laser
para medir distâncias com alta precisão.
O funcionamento do LIDAR baseia‑se na emissão de feixes de laser em alta
frequência em várias direções. Eles atingem objetos ao redor e retornam ao
sensor. Medindo o tempo que o pulso leva para ir até o objeto e voltar, o sistema
calcula a distância até esse objeto com grande exatidão. A partir da coleta
de milhares ou milhões de pontos por segundo, o LIDAR gera uma nuvem de
pontos tridimensional que representa a forma, a posição e, em alguns casos, até
a densidade dos objetos no entorno do veículo


time.sleep(segundos) Interrompe a execução do programa por um número de segundos especificado. No código, simula
o tempo necessário para processar uma tarefa
list.pop(índice) Remove e retorna o elemento da lista na posição indicada. Quando usado com o índice 0, remove o
primeiro elemento, simulando uma fila (estrutura FIFO)

time.strftime(‘%H:%M:%S’) Retorna a hora atual formatada como uma string no formato horas:minutos:segundos.
No código, é utilizada para registrar o horário de chegada das requisições
i % len(lista) Calcula o resto da divisão de i pelo comprimento da lista. Essa operação é usada para percorrer
elementos de forma cíclica, garantindo que os índices se mantenham dentro dos limites da lista



blockchain é um sistema distribuído e descentralizado que registra transações
em blocos interligados, garantindo transparência, imutabilidade e segurança. Essa infraestrutura tem
ganhado destaque em diversos setores, desde finanças até cadeias de suprimentos, pois permite a
verificação confiável de operações sem a necessidade de intermediários centralizados.



list como pilha (append + pop
sem índice)
A lista é utilizada como estrutura de pilha (LIFO), com append()para empilhar e
pop() (sem argumento) para desempilhar o último elemento inserido
for elemento in lista Itera sobre todos os elementos de uma lista, executando um bloco de código para
cada item. No código, é usado para percorrer as transações e exibi-las na tela