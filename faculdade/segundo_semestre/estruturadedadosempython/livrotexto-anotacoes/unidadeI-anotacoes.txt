unidadeI-anotacoes

1 INTRODUÇÃO A ALGORITMOS, LINGUAGEM PYTHON E ESTRUTURAS DE DADOS

Python => clareza e simplicidade

-algoritmo => sequência finita de passos bem definidos, projetados
para resolver um problema ou executar uma tarefa específica. 
desde de operações
matemáticas simples, como somar dois números, até processos mais complexos, como ordenar grandes
volumes de dados ou realizar buscas em estruturas de informação

-estruturas de dados => maneiras de organizar, armazenar e manipular os dados necessários para que algoritmos sejam executados
de maneira eficiente.

-relevância dos algoritmos => capacidade de automatizar processos, reduzindo
o esforço humano necessário para realizar tarefas repetitivas ou complicadas

-desempenham papel em todos os campos da tecnologia moderna, desde o aprendizado de máquina e a
inteligência artificial até a gestão de bancos de dados e os sistemas operacionais

-escolha de algoritmos => significar a diferença entre uma aplicação funcional e eficiente e outra que consome
recursos desnecessários ou apresenta baixo desempenho.

-Estruturas de dados: fornecer os meios para que informações
sejam organizadas e acessadas de maneira eficiente. Com a correta operações( busca, inserção, remoção ou ordenação de dados) podem ser realizadas com maior rapidez, com economia de tempo e recursos computacionais.

- Big‑O  => instrumentos mais utilizados para descrever
a complexidade de algoritmos, pois oferece uma forma padronizada de expressar o comportamento
de uma solução conforme o tamanho do conjunto de dados aumenta.
essencial: aplicações que lidam com grandes volumes de dados, nos quais pequenas diferenças
na eficiência podem ter impactos significativos.

- Big O => a ferramenta essencial para descrever o comportamento
de algoritmos em termos de complexidade de tempo e espaço. Usa símbolos matemáticos
para expressar como o desempenho de um algoritmo escala em relação ao tamanho do conjunto de
entrada. O(1) indica que o tempo de execução é constante, independentemente do tamanho
da entrada
O(n), por outro lado, indica que o tempo de execução aumenta linearmente com
o tamanho da entrada, como em busca linear

#Conceitos fundamentais: o que são algoritmos e estruturas de dados e
como utilizar a linguagem Python

-algoritmo =>  comparado a uma receita de cozinha,  descreve, passo a passo, o que deve ser feito para preparar um prato, um algoritmo apresenta
uma sequência clara e ordenada de instruções para resolver um problema ou realizar uma tarefa.  pode ser encontrado em diversas situações diárias.
exemplo, quando alguém explica como chegar a um local desconhecido, descrevendo o caminho em
etapas, está, na prática, criando um algoritmo. 

- na computação =>  é um conjunto de instruções que um computador pode
seguir para realizar uma operação específica

 maneira mais técnica, um algoritmo pode ser definido como uma sequência finita, ordenada e
bem definida de instruções que, ao serem executadas, resolvem um problema específico ou realizam
uma tarefa. 
fundamenta‑se em princípios de lógica matemática e de estruturação computaciona

-algoritmo deve atender a certas propriedades

• Finitude: um algoritmo deve sempre terminar após um número finito de passos. Ele não pode
continuar indefinidamente, a menos que seja projetado especificamente para isso
• Precisão: cada passo de um algoritmo precisa ser bem definido, ou seja, sem ambiguidades.
O computador (ou o executor humano) deve ser capaz de compreender e executar cada etapa
exatamente como descrita.
• Entrada: um algoritmo recebe zero ou mais entradas, que são os dados iniciais necessários para
começar o processamento.
• Saída: um algoritmo produz uma ou mais saídas, que são os resultados esperados após a execução
das instruções.
• Eficácia: cada instrução do algoritmo deve ser suficientemente básica para que possa ser
executada em tempo finito, utilizando recursos computacionais disponíveis.

 Ele é geralmente descrito em forma de
pseudocódigo ou de fluxograma antes de ser traduzido para código executável, o que facilita sua
compreensão e sua análise.

Para ilustrar, considere o problema clássico de determinar se um número inteiro é par ou ímpar.
Um algoritmo técnico para resolver esse problema pode ser descrito assim como segue.
• Receber um número inteiro como entrada.
• Dividir o número por 2 e calcular o resto (operação de módulo).
• Se o resto for igual a 0, o número será par.
• Caso contrário, o número será ímpar.
• Retornar o resultado (par ou ímpar).
O pseudocódigo desse algoritmo seria como vemos a seguir.
Entrada: número inteiro `n`
Se (n % 2 == 0):
Retornar “Par”
Senão:
Retornar “Ímpar”

análise mais técnica também inclui a eficiência do algoritmo, que é avaliada em termos de sua
complexidade de tempo e espaço.

exemplo anterior, a complexidade de tempo é O(1), porque
a operação de módulo é executada em tempo constante, independentemente do tamanho da entrada. 
 é verdade que, em uma execução prática, verificar se
o número 2 é par será ligeiramente mais rápido do que verificar se o número 10 bilhões é par. Entretanto,
essa diferença, no contexto da complexidade computacional, não é relevante ou significativa o suficiente
para alterar a classificação.

complexidade O(1) não significa que o algoritmo levará exatamente o mesmo número de
nanossegundos ou ciclos do processador independentemente do tamanho exato da entrada. Em vez
disso, é que o número de passos fundamentais do algoritmo não aumenta conforme
a entrada cresce. É o número de operações básicas, como somar, dividir ou testar uma condição simples,
que permanece constante. 


-Python é uma linguagem de programação de alto nível
Criada por Guido van Rossum na década de 1990, Python é usada em diversas áreas, como
desenvolvimento web, ciência de dados, inteligência artificial e automação de tarefas.
 ela é interpretada, o que significa que seu código não precisa ser
compilado antes de ser executado

-Essa flexibilidade caracteriza a tipagem
dinâmica: não é necessário declarar antecipadamente o tipo de dado, pois Python identifica
automaticamente se a variável conterá números, textos, listas ou outros objetos.

o conceito de função, que é um bloco de código nomeado,
responsável por encapsular operações reutilizáveis e separar responsabilidades

síntese, variáveis fornecem meios de nomear e manipular dados ao longo da execução,
enquanto funções promovem a organização do código em módulos concisos e reutilizáveis.

laço while repete um bloco
enquanto uma condição permanecer verdadeira. No trecho a seguir, o código solicita ao usuário que
digite a palavra sair para interromper o processo:

comando = “”
while comando != “sair”:
	comando = input(“Digite ‘sair’ para encerrar: “)
print(“Programa encerrado”)

A observância rigorosa da indentação é imprescindível: qualquer desalinhamento gera erro de
sintaxe, impedindo a execução do programa. Em caso de recuos inconsistentes, Python sinaliza
IndentationError, indicando que foi encontrada uma posição inesperada. 


--  generator expression é um recurso da Python que permite
criar coleções de maneira concisa e eficiente. Seu uso evita a necessidade
de laços explícitos (for) e torna o código mais legível. Em vez de criar e
armazenar a lista inteira na memória, ele gera os elementos sob demanda,
economizando espaço. Por exemplo, ao invés de escrever um laço for
tradicional para criar uma lista de quadrados dos números de 1 a 10,
podemos usar o generator expression:

 expressão geradora é que os valores não são armazenados
em uma lista, mas sim calculados conforme necessário. Essa característica
torna o método muito mais eficiente em termos de uso de memória, 


 conceitos de list comprehension e generator expression são recursos
do Python que evitam a necessidade de laços explícitos (for) e tornam o
código mais legível. No entanto, há diferenças fundamentais entre eles,
principalmente no modo como armazenam e processam os dados. A list
comprehension é uma maneira compacta de criar listas a partir de uma
sequência de elementos, aplicando transformações e filtragens diretamente
na declaração da lista. Sua principal característica é que ela retorna
36
Unidade I
uma nova lista contendo todos os elementos gerados pela expressão
interna. Como o resultado é armazenado diretamente na memória

JSON (JavaScript Object Notation) é um formato de armazenamento e troca de dados que organiza
informações de maneira estruturada e de fácil leitura, tanto para humanos quanto para computadores. 

utiliza uma estrutura baseada em pares chave‑valor, semelhante a dicionários em Python ou objetos
em JavaScript,

API (Interface de Programação de Aplicações) é um conjunto de
regras e definições que permite que diferentes sistemas e programas se
comuniquem entre si

#1.2 Análise de complexidade: introdução à notação Big‑O e à análise
de eficiência

auxilia na tomada de decisões sobre qual estratégia de implementação é mais adequada
para problemas que demandam alto desempenho ou lidam com grandes quantidades de dados


o comportamento assintótico refere‑se à forma como uma função se comporta quando seu
parâmetro tende ao infinito.


algoritmos => deseja‑se saber como o tempo de execução
(ou uso de memória) varia em função do tamanho da entrada, denotado com frequência por 𝑛.

interessa mais a taxa de crescimento desses recursos à medida que 𝑛 aumenta

o Big‑O é a forma mais amplamente utilizada para descrever limites superiores de crescimento

exemplo: algoritmo 𝐴 tem complexidade 𝑂(𝑓(𝑛)) significa que, para entradas
suficientemente grandes, o tempo de execução de 𝐴 não cresce mais rápido do que uma função
constante vezes 𝑓(𝑛)

 Se a sala tem 10 alunos, você faz 10 verificações; se tem 100, faz 100
verificações e assim por diante. Esse é um exemplo de comportamento linear: conforme o número de
alunos 𝑛 cresce, o trabalho sobe de forma proporcional e por isso dizemos que a tarefa está em 𝑂(𝑛).
Usando a definição de Big‑O:
• 𝐴(𝑛) é o tempo para conferir todas as assinaturas.
• 𝑓(𝑛) pode ser simplesmente n

execução constante, o que significa que não sofrem variação
perceptível à medida que o tamanho da entrada cresce. São classificados como 0(1). Um exemplo típico
desse comportamento é o acesso a um elemento específico de um array (ou lista) por índice: teoricamente,
considera‑se que buscar o valor em uma posição já conhecida tem custo fixo, independentemente de
quantos elementos existem ao todo.

m algoritmos cujo tempo de execução é logarítmico, especialmente quando
o tamanho do problema é reduzido pela metade (ou por um fator constante) a cada passo. A busca
binária em uma lista ordenada é um exemplo clássico: a cada comparação, descarta‑se metade dos
elementos, o que faz a quantidade de passos crescer de forma proporcional a log  


 𝑂(𝑛 log 𝑛), costuma-se dizer que ele é
linear‑logarítmico (Merge Sort
e Quick Sort (na média).)


𝑂(𝑛2). Isso é frequente em
algoritmos que utilizam laços aninhados, como Bubble Sort e Insertion Sort, em que para cada elemento
da lista é preciso percorrer novamente toda a lista (ou uma fração significativa dela).


𝑂(𝑛3
), que surge em algoritmos
com tripla aninhada de laços, por exemplo, em métodos básicos de multiplicação de matrizes. Já 𝑂(2𝑛)
é frequente em algoritmos de força bruta, que testam todas as combinações possíveis para resolver um
problema de decisão

 𝑂(𝑛!)  => caixeiro viajante


No uso prático, nem sempre o algoritmo assintoticamente mais rápido é o mais indicado. Para
entradas pequenas, métodos 𝑂(𝑛2
) podem superar outros 𝑂(𝑛 log 𝑛) devido a fatores como constantes
menores de tempo ou melhor uso de cache. É por isso que engenheiros e cientistas da computação
realizam não apenas análise teórica, mas testes empíricos (microbenchmarks) para embasar suas
decisões. 


Big‑O é uma forma de medir e comparar a eficiência de algoritmos ao analisar
como o tempo de execução (ou uso de memória) cresce conforme aumenta o tamanho da entrada

2 ESTRUTURAS DE DADOS LINEARES

organizam os elementos em
uma sequência ordenada, na qual cada item possui um predecessor e um sucessor (exceto o primeiro e
o último). 
elementos são acessados de maneira sequencial, respeitando
a ordem na qual foram inseridos. Diferentemente das estruturas não lineares, como árvores e grafos,
que permitem múltiplas conexões entre os elementos, as estruturas lineares mantêm uma relação direta
entre os itens, o que facilita a manipulação e o processamento dos dados.


permite a realização de operações como pesquisa, inserção e remoção
com base na posição dos elementos. Em listas e arrays, por exemplo, o acesso a um item pode ser feito
por meio de um índice numérico, garantindo eficiência quando a posição do elemento é conhecida.
No entanto, a inserção e a remoção em determinadas posições podem exigir deslocamentos de outros
elementos, o que impacta o desempenho dependendo da implementação utilizada.


pilhas e filas são classificadas como estruturas lineares porque
seguem uma ordem específica de inserção e remoção.

LIFO (Last In, First Out) para pilhas e FIFO (First In, First Out) para listas

Quando há necessidade de relacionamentos hierárquicos entre elementos
ou múltiplas conexões, como acontece em árvores e grafos, as estruturas não lineares tornam‑se mais
apropriadas. Contudo, para armazenar e processar dados de forma sequencial, as estruturas lineares
continuam sendo uma das abordagens mais eficientes e amplamente utilizadas na computação.

Listas são adequadas para armazenamento genérico de elementos
heterogêneos, enquanto arrays são preferíveis para manipulação eficiente de dados homogêneos.
Pilhas são úteis em problemas que exigem rastreamento de estados anteriores, como a execução de
chamadas recursivas e o gerenciamento de histórico de navegação. Filas, por sua vez, são empregadas
em sistemas que necessitam de processamento sequencial de requisições, como filas de impressão
e algoritmos de escalonamento

2.1 Listas e arrays: manipulação, pesquisa, inserção e remoção

Função Descrição
datetime.now() Retorna a data e a hora atuais do sistema
timedelta(seconds=n) Cria um intervalo de ‘n’ segundos, utilizado para manipulação de datas e horários
sum(iterável) Calcula a soma dos elementos de um iterável (como listas e dicionários)
for elemento in iterável Itera sobre os elementos de um iterável, executando um bloco de código para cada item
dicionario[chave] Acessa o valor correspondente a uma chave dentro de um dicionário
dicionario[‘chave’] = valor Atribui um valor a uma chave específica dentro de um dicionário

range(início, fim)
Gera uma sequência de números inteiros, incluindo o valor inicial e excluindo o valor final.
No código, é usado implicitamente no for i in range(1, qtd_registros + 1)
para gerar os identificadores dos registros
random.choice(sequência) Retorna um elemento aleatório de uma sequência, como uma lista. No código, é usado
para escolher aleatoriamente um id_dispositivo
registros[-1] Acessa o último elemento da lista registros
timedelta(minutes=n) Cria um intervalo ‘n’ minutos, utilizado para cálculos com datas e horas. Já havia sido usada
com segundos, mas aqui há o uso específico de minutos


pag 72








