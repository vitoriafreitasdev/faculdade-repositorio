unidadeI-anotacoes

1 INTRODU√á√ÉO A ALGORITMOS, LINGUAGEM PYTHON E ESTRUTURAS DE DADOS

Python => clareza e simplicidade

-algoritmo => sequ√™ncia finita de passos bem definidos, projetados
para resolver um problema ou executar uma tarefa espec√≠fica. 
desde de opera√ß√µes
matem√°ticas simples, como somar dois n√∫meros, at√© processos mais complexos, como ordenar grandes
volumes de dados ou realizar buscas em estruturas de informa√ß√£o

-estruturas de dados => maneiras de organizar, armazenar e manipular os dados necess√°rios para que algoritmos sejam executados
de maneira eficiente.

-relev√¢ncia dos algoritmos => capacidade de automatizar processos, reduzindo
o esfor√ßo humano necess√°rio para realizar tarefas repetitivas ou complicadas

-desempenham papel em todos os campos da tecnologia moderna, desde o aprendizado de m√°quina e a
intelig√™ncia artificial at√© a gest√£o de bancos de dados e os sistemas operacionais

-escolha de algoritmos => significar a diferen√ßa entre uma aplica√ß√£o funcional e eficiente e outra que consome
recursos desnecess√°rios ou apresenta baixo desempenho.

-Estruturas de dados: fornecer os meios para que informa√ß√µes
sejam organizadas e acessadas de maneira eficiente. Com a correta opera√ß√µes( busca, inser√ß√£o, remo√ß√£o ou ordena√ß√£o de dados) podem ser realizadas com maior rapidez, com economia de tempo e recursos computacionais.

- Big‚ÄëO  => instrumentos mais utilizados para descrever
a complexidade de algoritmos, pois oferece uma forma padronizada de expressar o comportamento
de uma solu√ß√£o conforme o tamanho do conjunto de dados aumenta.
essencial: aplica√ß√µes que lidam com grandes volumes de dados, nos quais pequenas diferen√ßas
na efici√™ncia podem ter impactos significativos.

- Big O => a ferramenta essencial para descrever o comportamento
de algoritmos em termos de complexidade de tempo e espa√ßo. Usa s√≠mbolos matem√°ticos
para expressar como o desempenho de um algoritmo escala em rela√ß√£o ao tamanho do conjunto de
entrada. O(1) indica que o tempo de execu√ß√£o √© constante, independentemente do tamanho
da entrada
O(n), por outro lado, indica que o tempo de execu√ß√£o aumenta linearmente com
o tamanho da entrada, como em busca linear

ÔÇß Tamb√©m chamada de nota√ß√£o assint√≥tica ou nota√ß√£o de ordem de grandeza, √© utilizada para
descrever o comportamento de algoritmos conforme o tamanho da entrada cresce.
ÔÇß Essa nota√ß√£o permite representar a taxa de crescimento do tempo de execu√ß√£o ou do uso
de mem√≥ria, independentemente de detalhes espec√≠ficos de implementa√ß√£o ou de hardware.

comportamento assint√≥tico refere-se √† forma como uma fun√ß√£o cresce quando seu
par√¢metro, como o tamanho da entrada de um algoritmo, tende ao infinito.
ÔÇß No contexto dos algoritmos, essa an√°lise avalia como o tempo de execu√ß√£o ou o uso de
mem√≥ria se modifica √† medida que n, o tamanho da entrada, se eleva consideravelmente.

#Conceitos fundamentais: o que s√£o algoritmos e estruturas de dados e
como utilizar a linguagem Python

-algoritmo =>  comparado a uma receita de cozinha,  descreve, passo a passo, o que deve ser feito para preparar um prato, um algoritmo apresenta
uma sequ√™ncia clara e ordenada de instru√ß√µes para resolver um problema ou realizar uma tarefa.  pode ser encontrado em diversas situa√ß√µes di√°rias.
exemplo, quando algu√©m explica como chegar a um local desconhecido, descrevendo o caminho em
etapas, est√°, na pr√°tica, criando um algoritmo. 

- na computa√ß√£o =>  √© um conjunto de instru√ß√µes que um computador pode
seguir para realizar uma opera√ß√£o espec√≠fica

 maneira mais t√©cnica, um algoritmo pode ser definido como uma sequ√™ncia finita, ordenada e
bem definida de instru√ß√µes que, ao serem executadas, resolvem um problema espec√≠fico ou realizam
uma tarefa. 
fundamenta‚Äëse em princ√≠pios de l√≥gica matem√°tica e de estrutura√ß√£o computaciona

-algoritmo deve atender a certas propriedades

‚Ä¢ Finitude: um algoritmo deve sempre terminar ap√≥s um n√∫mero finito de passos. Ele n√£o pode
continuar indefinidamente, a menos que seja projetado especificamente para isso
‚Ä¢ Precis√£o: cada passo de um algoritmo precisa ser bem definido, ou seja, sem ambiguidades.
O computador (ou o executor humano) deve ser capaz de compreender e executar cada etapa
exatamente como descrita.
‚Ä¢ Entrada: um algoritmo recebe zero ou mais entradas, que s√£o os dados iniciais necess√°rios para
come√ßar o processamento.
‚Ä¢ Sa√≠da: um algoritmo produz uma ou mais sa√≠das, que s√£o os resultados esperados ap√≥s a execu√ß√£o
das instru√ß√µes.
‚Ä¢ Efic√°cia: cada instru√ß√£o do algoritmo deve ser suficientemente b√°sica para que possa ser
executada em tempo finito, utilizando recursos computacionais dispon√≠veis.

 Ele √© geralmente descrito em forma de
pseudoc√≥digo ou de fluxograma antes de ser traduzido para c√≥digo execut√°vel, o que facilita sua
compreens√£o e sua an√°lise.

Para ilustrar, considere o problema cl√°ssico de determinar se um n√∫mero inteiro √© par ou √≠mpar.
Um algoritmo t√©cnico para resolver esse problema pode ser descrito assim como segue.
‚Ä¢ Receber um n√∫mero inteiro como entrada.
‚Ä¢ Dividir o n√∫mero por 2 e calcular o resto (opera√ß√£o de m√≥dulo).
‚Ä¢ Se o resto for igual a 0, o n√∫mero ser√° par.
‚Ä¢ Caso contr√°rio, o n√∫mero ser√° √≠mpar.
‚Ä¢ Retornar o resultado (par ou √≠mpar).
O pseudoc√≥digo desse algoritmo seria como vemos a seguir.
Entrada: n√∫mero inteiro `n`
Se (n % 2 == 0):
Retornar ‚ÄúPar‚Äù
Sen√£o:
Retornar ‚Äú√çmpar‚Äù

an√°lise mais t√©cnica tamb√©m inclui a efici√™ncia do algoritmo, que √© avaliada em termos de sua
complexidade de tempo e espa√ßo.

exemplo anterior, a complexidade de tempo √© O(1), porque
a opera√ß√£o de m√≥dulo √© executada em tempo constante, independentemente do tamanho da entrada. 
 √© verdade que, em uma execu√ß√£o pr√°tica, verificar se
o n√∫mero 2 √© par ser√° ligeiramente mais r√°pido do que verificar se o n√∫mero 10 bilh√µes √© par. Entretanto,
essa diferen√ßa, no contexto da complexidade computacional, n√£o √© relevante ou significativa o suficiente
para alterar a classifica√ß√£o.

complexidade O(1) n√£o significa que o algoritmo levar√° exatamente o mesmo n√∫mero de
nanossegundos ou ciclos do processador independentemente do tamanho exato da entrada. Em vez
disso, √© que o n√∫mero de passos fundamentais do algoritmo n√£o aumenta conforme
a entrada cresce. √â o n√∫mero de opera√ß√µes b√°sicas, como somar, dividir ou testar uma condi√ß√£o simples,
que permanece constante. 


-Python √© uma linguagem de programa√ß√£o de alto n√≠vel
Criada por Guido van Rossum na d√©cada de 1990, Python √© usada em diversas √°reas, como
desenvolvimento web, ci√™ncia de dados, intelig√™ncia artificial e automa√ß√£o de tarefas.
 ela √© interpretada, o que significa que seu c√≥digo n√£o precisa ser
compilado antes de ser executado

-Essa flexibilidade caracteriza a tipagem
din√¢mica: n√£o √© necess√°rio declarar antecipadamente o tipo de dado, pois Python identifica
automaticamente se a vari√°vel conter√° n√∫meros, textos, listas ou outros objetos.

o conceito de fun√ß√£o, que √© um bloco de c√≥digo nomeado,
respons√°vel por encapsular opera√ß√µes reutiliz√°veis e separar responsabilidades

s√≠ntese, vari√°veis fornecem meios de nomear e manipular dados ao longo da execu√ß√£o,
enquanto fun√ß√µes promovem a organiza√ß√£o do c√≥digo em m√≥dulos concisos e reutiliz√°veis.

la√ßo while repete um bloco
enquanto uma condi√ß√£o permanecer verdadeira. No trecho a seguir, o c√≥digo solicita ao usu√°rio que
digite a palavra sair para interromper o processo:

comando = ‚Äú‚Äù
while comando != ‚Äúsair‚Äù:
	comando = input(‚ÄúDigite ‚Äòsair‚Äô para encerrar: ‚Äú)
print(‚ÄúPrograma encerrado‚Äù)

A observ√¢ncia rigorosa da indenta√ß√£o √© imprescind√≠vel: qualquer desalinhamento gera erro de
sintaxe, impedindo a execu√ß√£o do programa. Em caso de recuos inconsistentes, Python sinaliza
IndentationError, indicando que foi encontrada uma posi√ß√£o inesperada. 


--  generator expression √© um recurso da Python que permite
criar cole√ß√µes de maneira concisa e eficiente. Seu uso evita a necessidade
de la√ßos expl√≠citos (for) e torna o c√≥digo mais leg√≠vel. Em vez de criar e
armazenar a lista inteira na mem√≥ria, ele gera os elementos sob demanda,
economizando espa√ßo. Por exemplo, ao inv√©s de escrever um la√ßo for
tradicional para criar uma lista de quadrados dos n√∫meros de 1 a 10,
podemos usar o generator expression:

 express√£o geradora √© que os valores n√£o s√£o armazenados
em uma lista, mas sim calculados conforme necess√°rio. Essa caracter√≠stica
torna o m√©todo muito mais eficiente em termos de uso de mem√≥ria, 


 conceitos de list comprehension e generator expression s√£o recursos
do Python que evitam a necessidade de la√ßos expl√≠citos (for) e tornam o
c√≥digo mais leg√≠vel. No entanto, h√° diferen√ßas fundamentais entre eles,
principalmente no modo como armazenam e processam os dados. A list
comprehension √© uma maneira compacta de criar listas a partir de uma
sequ√™ncia de elementos, aplicando transforma√ß√µes e filtragens diretamente
na declara√ß√£o da lista. Sua principal caracter√≠stica √© que ela retorna
36
Unidade I
uma nova lista contendo todos os elementos gerados pela express√£o
interna. Como o resultado √© armazenado diretamente na mem√≥ria

JSON (JavaScript Object Notation) √© um formato de armazenamento e troca de dados que organiza
informa√ß√µes de maneira estruturada e de f√°cil leitura, tanto para humanos quanto para computadores. 

utiliza uma estrutura baseada em pares chave‚Äëvalor, semelhante a dicion√°rios em Python ou objetos
em JavaScript,

API (Interface de Programa√ß√£o de Aplica√ß√µes) √© um conjunto de
regras e defini√ß√µes que permite que diferentes sistemas e programas se
comuniquem entre si

#1.2 An√°lise de complexidade: introdu√ß√£o √† nota√ß√£o Big‚ÄëO e √† an√°lise
de efici√™ncia

auxilia na tomada de decis√µes sobre qual estrat√©gia de implementa√ß√£o √© mais adequada
para problemas que demandam alto desempenho ou lidam com grandes quantidades de dados


o comportamento assint√≥tico refere‚Äëse √† forma como uma fun√ß√£o se comporta quando seu
par√¢metro tende ao infinito.


algoritmos => deseja‚Äëse saber como o tempo de execu√ß√£o
(ou uso de mem√≥ria) varia em fun√ß√£o do tamanho da entrada, denotado com frequ√™ncia por ùëõ.

interessa mais a taxa de crescimento desses recursos √† medida que ùëõ aumenta

o Big‚ÄëO √© a forma mais amplamente utilizada para descrever limites superiores de crescimento

exemplo: algoritmo ùê¥ tem complexidade ùëÇ(ùëì(ùëõ)) significa que, para entradas
suficientemente grandes, o tempo de execu√ß√£o de ùê¥ n√£o cresce mais r√°pido do que uma fun√ß√£o
constante vezes ùëì(ùëõ)

 Se a sala tem 10 alunos, voc√™ faz 10 verifica√ß√µes; se tem 100, faz 100
verifica√ß√µes e assim por diante. Esse √© um exemplo de comportamento linear: conforme o n√∫mero de
alunos ùëõ cresce, o trabalho sobe de forma proporcional e por isso dizemos que a tarefa est√° em ùëÇ(ùëõ).
Usando a defini√ß√£o de Big‚ÄëO:
‚Ä¢ ùê¥(ùëõ) √© o tempo para conferir todas as assinaturas.
‚Ä¢ ùëì(ùëõ) pode ser simplesmente n

execu√ß√£o constante, o que significa que n√£o sofrem varia√ß√£o
percept√≠vel √† medida que o tamanho da entrada cresce. S√£o classificados como 0(1). Um exemplo t√≠pico
desse comportamento √© o acesso a um elemento espec√≠fico de um array (ou lista) por √≠ndice: teoricamente,
considera‚Äëse que buscar o valor em uma posi√ß√£o j√° conhecida tem custo fixo, independentemente de
quantos elementos existem ao todo.

m algoritmos cujo tempo de execu√ß√£o √© logar√≠tmico, especialmente quando
o tamanho do problema √© reduzido pela metade (ou por um fator constante) a cada passo. A busca
bin√°ria em uma lista ordenada √© um exemplo cl√°ssico: a cada compara√ß√£o, descarta‚Äëse metade dos
elementos, o que faz a quantidade de passos crescer de forma proporcional a log  


 ùëÇ(ùëõ log ùëõ), costuma-se dizer que ele √©
linear‚Äëlogar√≠tmico (Merge Sort
e Quick Sort (na m√©dia).)


ùëÇ(ùëõ2). Isso √© frequente em
algoritmos que utilizam la√ßos aninhados, como Bubble Sort e Insertion Sort, em que para cada elemento
da lista √© preciso percorrer novamente toda a lista (ou uma fra√ß√£o significativa dela).


ùëÇ(ùëõ3
), que surge em algoritmos
com tripla aninhada de la√ßos, por exemplo, em m√©todos b√°sicos de multiplica√ß√£o de matrizes. J√° ùëÇ(2ùëõ)
√© frequente em algoritmos de for√ßa bruta, que testam todas as combina√ß√µes poss√≠veis para resolver um
problema de decis√£o

 ùëÇ(ùëõ!)  => caixeiro viajante


No uso pr√°tico, nem sempre o algoritmo assintoticamente mais r√°pido √© o mais indicado. Para
entradas pequenas, m√©todos ùëÇ(ùëõ2
) podem superar outros ùëÇ(ùëõ log ùëõ) devido a fatores como constantes
menores de tempo ou melhor uso de cache. √â por isso que engenheiros e cientistas da computa√ß√£o
realizam n√£o apenas an√°lise te√≥rica, mas testes emp√≠ricos (microbenchmarks) para embasar suas
decis√µes. 


Big‚ÄëO √© uma forma de medir e comparar a efici√™ncia de algoritmos ao analisar
como o tempo de execu√ß√£o (ou uso de mem√≥ria) cresce conforme aumenta o tamanho da entrada

2 ESTRUTURAS DE DADOS LINEARES

organizam os elementos em
uma sequ√™ncia ordenada, na qual cada item possui um predecessor e um sucessor (exceto o primeiro e
o √∫ltimo). 
elementos s√£o acessados de maneira sequencial, respeitando
a ordem na qual foram inseridos. Diferentemente das estruturas n√£o lineares, como √°rvores e grafos,
que permitem m√∫ltiplas conex√µes entre os elementos, as estruturas lineares mant√™m uma rela√ß√£o direta
entre os itens, o que facilita a manipula√ß√£o e o processamento dos dados.


permite a realiza√ß√£o de opera√ß√µes como pesquisa, inser√ß√£o e remo√ß√£o
com base na posi√ß√£o dos elementos. Em listas e arrays, por exemplo, o acesso a um item pode ser feito
por meio de um √≠ndice num√©rico, garantindo efici√™ncia quando a posi√ß√£o do elemento √© conhecida.
No entanto, a inser√ß√£o e a remo√ß√£o em determinadas posi√ß√µes podem exigir deslocamentos de outros
elementos, o que impacta o desempenho dependendo da implementa√ß√£o utilizada.


pilhas e filas s√£o classificadas como estruturas lineares porque
seguem uma ordem espec√≠fica de inser√ß√£o e remo√ß√£o.

LIFO (Last In, First Out) para pilhas e FIFO (First In, First Out) para listas

Quando h√° necessidade de relacionamentos hier√°rquicos entre elementos
ou m√∫ltiplas conex√µes, como acontece em √°rvores e grafos, as estruturas n√£o lineares tornam‚Äëse mais
apropriadas. Contudo, para armazenar e processar dados de forma sequencial, as estruturas lineares
continuam sendo uma das abordagens mais eficientes e amplamente utilizadas na computa√ß√£o.

Listas s√£o adequadas para armazenamento gen√©rico de elementos
heterog√™neos, enquanto arrays s√£o prefer√≠veis para manipula√ß√£o eficiente de dados homog√™neos.
Pilhas s√£o √∫teis em problemas que exigem rastreamento de estados anteriores, como a execu√ß√£o de
chamadas recursivas e o gerenciamento de hist√≥rico de navega√ß√£o. Filas, por sua vez, s√£o empregadas
em sistemas que necessitam de processamento sequencial de requisi√ß√µes, como filas de impress√£o
e algoritmos de escalonamento

2.1 Listas e arrays: manipula√ß√£o, pesquisa, inser√ß√£o e remo√ß√£o

Fun√ß√£o Descri√ß√£o
datetime.now() Retorna a data e a hora atuais do sistema
timedelta(seconds=n) Cria um intervalo de ‚Äòn‚Äô segundos, utilizado para manipula√ß√£o de datas e hor√°rios
sum(iter√°vel) Calcula a soma dos elementos de um iter√°vel (como listas e dicion√°rios)
for elemento in iter√°vel Itera sobre os elementos de um iter√°vel, executando um bloco de c√≥digo para cada item
dicionario[chave] Acessa o valor correspondente a uma chave dentro de um dicion√°rio
dicionario[‚Äòchave‚Äô] = valor Atribui um valor a uma chave espec√≠fica dentro de um dicion√°rio

range(in√≠cio, fim)
Gera uma sequ√™ncia de n√∫meros inteiros, incluindo o valor inicial e excluindo o valor final.
No c√≥digo, √© usado implicitamente no for i in range(1, qtd_registros + 1)
para gerar os identificadores dos registros
random.choice(sequ√™ncia) Retorna um elemento aleat√≥rio de uma sequ√™ncia, como uma lista. No c√≥digo, √© usado
para escolher aleatoriamente um id_dispositivo
registros[-1] Acessa o √∫ltimo elemento da lista registros
timedelta(minutes=n) Cria um intervalo ‚Äòn‚Äô minutos, utilizado para c√°lculos com datas e horas. J√° havia sido usada
com segundos, mas aqui h√° o uso espec√≠fico de minutos



np.dtype([...]) - Define a estrutura de um tipo composto para arrays NumPy, permitindo armazenar
diferentes campos (como um registro com timestamp, IP, usu√°rio e status) em um √∫nico array
estruturado


np.empty(tamanho, dtype=...) - Cria um array n√£o inicializado (com valores arbitr√°rios) com o n√∫mero de elementos e tipo
especificado, usado para otimizar desempenho quando os valores ser√£o preenchidos logo em seguida

np.array([...]) Cria um array NumPy a partir de uma lista ou tupla de dados. No c√≥digo, √© usado tanto para
listas de valores quanto para constru√ß√£o de um novo registro

np.random.choice(array) Escolhe aleatoriamente um elemento de um array. Pode incluir o par√¢metro p=... para
atribuir probabilidades aos elementos

np.datetime64(data, unidade) Converte um valor de tempo (como um datetime) para o tipo datetime64 do NumPy,
usado para compatibilidade com arrays estruturados e opera√ß√µes vetoriais
np.timedelta64(valor, unidade) Representa uma diferen√ßa de tempo no formato do NumPy, usado para realizar somas com
datas em arrays

array[‚Äòcampo‚Äô] Acessa os valores de um campo espec√≠fico em um array estruturado. Por exemplo,
registros[‚Äòip‚Äô] retorna todos os IPs registrados

np.unique(array, return_
counts=True)
Retorna os elementos √∫nicos do array e, se return_counts=True, tamb√©m a contagem
de cada elemento. No c√≥digo, √© usado para contar falhas por IP

np.append(array, novo_
elemento)

Retorna um novo array com o elemento adicionado ao final. No c√≥digo, √©
usado para inserir um novo log no array de registros

.astype(tipo)
Converte o tipo de dados de um array ou campo. No c√≥digo, √© utilizado para converter
datetime64 do NumPy para objetos datetime do Python padr√£o, a fim de imprimir de
forma leg√≠vel


Lat√™ncia refere‚Äëse ao intervalo entre o momento em que um dado
entra na estrutura e o instante em que se obt√©m resposta ou se processa
a pr√≥xima etapa. Em rob√≥tica, lat√™ncia reduzida garante rea√ß√µes r√°pidas;
em atendimento, evita demora percept√≠vel ao cliente; na blockchain,
minimiza  o tempo necess√°rio para que uma transa√ß√£o seja inclu√≠da em
bloco. O controle de lat√™ncia envolve escolha da estrutura, afina√ß√£o de
algoritmos e otimiza√ß√£o de hardware subjacente.


O termo LIDAR deriva de ‚ÄúLight Detection and Ranging‚Äù, ou ‚ÄúDetec√ß√£o
e Medi√ß√£o por Luz‚Äù, e refere‚Äëse a uma tecnologia que utiliza pulsos de laser
para medir dist√¢ncias com alta precis√£o.
O funcionamento do LIDAR baseia‚Äëse na emiss√£o de feixes de laser em alta
frequ√™ncia em v√°rias dire√ß√µes. Eles atingem objetos ao redor e retornam ao
sensor. Medindo o tempo que o pulso leva para ir at√© o objeto e voltar, o sistema
calcula a dist√¢ncia at√© esse objeto com grande exatid√£o. A partir da coleta
de milhares ou milh√µes de pontos por segundo, o LIDAR gera uma nuvem de
pontos tridimensional que representa a forma, a posi√ß√£o e, em alguns casos, at√©
a densidade dos objetos no entorno do ve√≠culo


time.sleep(segundos) Interrompe a execu√ß√£o do programa por um n√∫mero de segundos especificado. No c√≥digo, simula
o tempo necess√°rio para processar uma tarefa
list.pop(√≠ndice) Remove e retorna o elemento da lista na posi√ß√£o indicada. Quando usado com o √≠ndice 0, remove o
primeiro elemento, simulando uma fila (estrutura FIFO)

time.strftime(‚Äò%H:%M:%S‚Äô) Retorna a hora atual formatada como uma string no formato horas:minutos:segundos.
No c√≥digo, √© utilizada para registrar o hor√°rio de chegada das requisi√ß√µes
i % len(lista) Calcula o resto da divis√£o de i pelo comprimento da lista. Essa opera√ß√£o √© usada para percorrer
elementos de forma c√≠clica, garantindo que os √≠ndices se mantenham dentro dos limites da lista



blockchain √© um sistema distribu√≠do e descentralizado que registra transa√ß√µes
em blocos interligados, garantindo transpar√™ncia, imutabilidade e seguran√ßa. Essa infraestrutura tem
ganhado destaque em diversos setores, desde finan√ßas at√© cadeias de suprimentos, pois permite a
verifica√ß√£o confi√°vel de opera√ß√µes sem a necessidade de intermedi√°rios centralizados.



list como pilha (append + pop
sem √≠ndice)
A lista √© utilizada como estrutura de pilha (LIFO), com append()para empilhar e
pop() (sem argumento) para desempilhar o √∫ltimo elemento inserido
for elemento in lista Itera sobre todos os elementos de uma lista, executando um bloco de c√≥digo para
cada item. No c√≥digo, √© usado para percorrer as transa√ß√µes e exibi-las na tela