unidadeI-anotacoes

1 INTRODUÃ‡ÃƒO A ALGORITMOS, LINGUAGEM PYTHON E ESTRUTURAS DE DADOS

Python => clareza e simplicidade

-algoritmo => sequÃªncia finita de passos bem definidos, projetados
para resolver um problema ou executar uma tarefa especÃ­fica. 
desde de operaÃ§Ãµes
matemÃ¡ticas simples, como somar dois nÃºmeros, atÃ© processos mais complexos, como ordenar grandes
volumes de dados ou realizar buscas em estruturas de informaÃ§Ã£o

-estruturas de dados => maneiras de organizar, armazenar e manipular os dados necessÃ¡rios para que algoritmos sejam executados
de maneira eficiente.

-relevÃ¢ncia dos algoritmos => capacidade de automatizar processos, reduzindo
o esforÃ§o humano necessÃ¡rio para realizar tarefas repetitivas ou complicadas

-desempenham papel em todos os campos da tecnologia moderna, desde o aprendizado de mÃ¡quina e a
inteligÃªncia artificial atÃ© a gestÃ£o de bancos de dados e os sistemas operacionais

-escolha de algoritmos => significar a diferenÃ§a entre uma aplicaÃ§Ã£o funcional e eficiente e outra que consome
recursos desnecessÃ¡rios ou apresenta baixo desempenho.

-Estruturas de dados: fornecer os meios para que informaÃ§Ãµes
sejam organizadas e acessadas de maneira eficiente. Com a correta operaÃ§Ãµes( busca, inserÃ§Ã£o, remoÃ§Ã£o ou ordenaÃ§Ã£o de dados) podem ser realizadas com maior rapidez, com economia de tempo e recursos computacionais.

- Bigâ€‘O  => instrumentos mais utilizados para descrever
a complexidade de algoritmos, pois oferece uma forma padronizada de expressar o comportamento
de uma soluÃ§Ã£o conforme o tamanho do conjunto de dados aumenta.
essencial: aplicaÃ§Ãµes que lidam com grandes volumes de dados, nos quais pequenas diferenÃ§as
na eficiÃªncia podem ter impactos significativos.

- Big O => a ferramenta essencial para descrever o comportamento
de algoritmos em termos de complexidade de tempo e espaÃ§o. Usa sÃ­mbolos matemÃ¡ticos
para expressar como o desempenho de um algoritmo escala em relaÃ§Ã£o ao tamanho do conjunto de
entrada. O(1) indica que o tempo de execuÃ§Ã£o Ã© constante, independentemente do tamanho
da entrada
O(n), por outro lado, indica que o tempo de execuÃ§Ã£o aumenta linearmente com
o tamanho da entrada, como em busca linear

#Conceitos fundamentais: o que sÃ£o algoritmos e estruturas de dados e
como utilizar a linguagem Python

-algoritmo =>  comparado a uma receita de cozinha,  descreve, passo a passo, o que deve ser feito para preparar um prato, um algoritmo apresenta
uma sequÃªncia clara e ordenada de instruÃ§Ãµes para resolver um problema ou realizar uma tarefa.  pode ser encontrado em diversas situaÃ§Ãµes diÃ¡rias.
exemplo, quando alguÃ©m explica como chegar a um local desconhecido, descrevendo o caminho em
etapas, estÃ¡, na prÃ¡tica, criando um algoritmo. 

- na computaÃ§Ã£o =>  Ã© um conjunto de instruÃ§Ãµes que um computador pode
seguir para realizar uma operaÃ§Ã£o especÃ­fica

 maneira mais tÃ©cnica, um algoritmo pode ser definido como uma sequÃªncia finita, ordenada e
bem definida de instruÃ§Ãµes que, ao serem executadas, resolvem um problema especÃ­fico ou realizam
uma tarefa. 
fundamentaâ€‘se em princÃ­pios de lÃ³gica matemÃ¡tica e de estruturaÃ§Ã£o computaciona

-algoritmo deve atender a certas propriedades

â€¢ Finitude: um algoritmo deve sempre terminar apÃ³s um nÃºmero finito de passos. Ele nÃ£o pode
continuar indefinidamente, a menos que seja projetado especificamente para isso
â€¢ PrecisÃ£o: cada passo de um algoritmo precisa ser bem definido, ou seja, sem ambiguidades.
O computador (ou o executor humano) deve ser capaz de compreender e executar cada etapa
exatamente como descrita.
â€¢ Entrada: um algoritmo recebe zero ou mais entradas, que sÃ£o os dados iniciais necessÃ¡rios para
comeÃ§ar o processamento.
â€¢ SaÃ­da: um algoritmo produz uma ou mais saÃ­das, que sÃ£o os resultados esperados apÃ³s a execuÃ§Ã£o
das instruÃ§Ãµes.
â€¢ EficÃ¡cia: cada instruÃ§Ã£o do algoritmo deve ser suficientemente bÃ¡sica para que possa ser
executada em tempo finito, utilizando recursos computacionais disponÃ­veis.

 Ele Ã© geralmente descrito em forma de
pseudocÃ³digo ou de fluxograma antes de ser traduzido para cÃ³digo executÃ¡vel, o que facilita sua
compreensÃ£o e sua anÃ¡lise.

Para ilustrar, considere o problema clÃ¡ssico de determinar se um nÃºmero inteiro Ã© par ou Ã­mpar.
Um algoritmo tÃ©cnico para resolver esse problema pode ser descrito assim como segue.
â€¢ Receber um nÃºmero inteiro como entrada.
â€¢ Dividir o nÃºmero por 2 e calcular o resto (operaÃ§Ã£o de mÃ³dulo).
â€¢ Se o resto for igual a 0, o nÃºmero serÃ¡ par.
â€¢ Caso contrÃ¡rio, o nÃºmero serÃ¡ Ã­mpar.
â€¢ Retornar o resultado (par ou Ã­mpar).
O pseudocÃ³digo desse algoritmo seria como vemos a seguir.
Entrada: nÃºmero inteiro `n`
Se (n % 2 == 0):
Retornar â€œParâ€
SenÃ£o:
Retornar â€œÃmparâ€

anÃ¡lise mais tÃ©cnica tambÃ©m inclui a eficiÃªncia do algoritmo, que Ã© avaliada em termos de sua
complexidade de tempo e espaÃ§o.

exemplo anterior, a complexidade de tempo Ã© O(1), porque
a operaÃ§Ã£o de mÃ³dulo Ã© executada em tempo constante, independentemente do tamanho da entrada. 
 Ã© verdade que, em uma execuÃ§Ã£o prÃ¡tica, verificar se
o nÃºmero 2 Ã© par serÃ¡ ligeiramente mais rÃ¡pido do que verificar se o nÃºmero 10 bilhÃµes Ã© par. Entretanto,
essa diferenÃ§a, no contexto da complexidade computacional, nÃ£o Ã© relevante ou significativa o suficiente
para alterar a classificaÃ§Ã£o.

complexidade O(1) nÃ£o significa que o algoritmo levarÃ¡ exatamente o mesmo nÃºmero de
nanossegundos ou ciclos do processador independentemente do tamanho exato da entrada. Em vez
disso, Ã© que o nÃºmero de passos fundamentais do algoritmo nÃ£o aumenta conforme
a entrada cresce. Ã‰ o nÃºmero de operaÃ§Ãµes bÃ¡sicas, como somar, dividir ou testar uma condiÃ§Ã£o simples,
que permanece constante. 


-Python Ã© uma linguagem de programaÃ§Ã£o de alto nÃ­vel
Criada por Guido van Rossum na dÃ©cada de 1990, Python Ã© usada em diversas Ã¡reas, como
desenvolvimento web, ciÃªncia de dados, inteligÃªncia artificial e automaÃ§Ã£o de tarefas.
 ela Ã© interpretada, o que significa que seu cÃ³digo nÃ£o precisa ser
compilado antes de ser executado

-Essa flexibilidade caracteriza a tipagem
dinÃ¢mica: nÃ£o Ã© necessÃ¡rio declarar antecipadamente o tipo de dado, pois Python identifica
automaticamente se a variÃ¡vel conterÃ¡ nÃºmeros, textos, listas ou outros objetos.

o conceito de funÃ§Ã£o, que Ã© um bloco de cÃ³digo nomeado,
responsÃ¡vel por encapsular operaÃ§Ãµes reutilizÃ¡veis e separar responsabilidades

sÃ­ntese, variÃ¡veis fornecem meios de nomear e manipular dados ao longo da execuÃ§Ã£o,
enquanto funÃ§Ãµes promovem a organizaÃ§Ã£o do cÃ³digo em mÃ³dulos concisos e reutilizÃ¡veis.

laÃ§o while repete um bloco
enquanto uma condiÃ§Ã£o permanecer verdadeira. No trecho a seguir, o cÃ³digo solicita ao usuÃ¡rio que
digite a palavra sair para interromper o processo:

comando = â€œâ€
while comando != â€œsairâ€:
	comando = input(â€œDigite â€˜sairâ€™ para encerrar: â€œ)
print(â€œPrograma encerradoâ€)

A observÃ¢ncia rigorosa da indentaÃ§Ã£o Ã© imprescindÃ­vel: qualquer desalinhamento gera erro de
sintaxe, impedindo a execuÃ§Ã£o do programa. Em caso de recuos inconsistentes, Python sinaliza
IndentationError, indicando que foi encontrada uma posiÃ§Ã£o inesperada. 


--  generator expression Ã© um recurso da Python que permite
criar coleÃ§Ãµes de maneira concisa e eficiente. Seu uso evita a necessidade
de laÃ§os explÃ­citos (for) e torna o cÃ³digo mais legÃ­vel. Em vez de criar e
armazenar a lista inteira na memÃ³ria, ele gera os elementos sob demanda,
economizando espaÃ§o. Por exemplo, ao invÃ©s de escrever um laÃ§o for
tradicional para criar uma lista de quadrados dos nÃºmeros de 1 a 10,
podemos usar o generator expression:

 expressÃ£o geradora Ã© que os valores nÃ£o sÃ£o armazenados
em uma lista, mas sim calculados conforme necessÃ¡rio. Essa caracterÃ­stica
torna o mÃ©todo muito mais eficiente em termos de uso de memÃ³ria, 


 conceitos de list comprehension e generator expression sÃ£o recursos
do Python que evitam a necessidade de laÃ§os explÃ­citos (for) e tornam o
cÃ³digo mais legÃ­vel. No entanto, hÃ¡ diferenÃ§as fundamentais entre eles,
principalmente no modo como armazenam e processam os dados. A list
comprehension Ã© uma maneira compacta de criar listas a partir de uma
sequÃªncia de elementos, aplicando transformaÃ§Ãµes e filtragens diretamente
na declaraÃ§Ã£o da lista. Sua principal caracterÃ­stica Ã© que ela retorna
36
Unidade I
uma nova lista contendo todos os elementos gerados pela expressÃ£o
interna. Como o resultado Ã© armazenado diretamente na memÃ³ria

JSON (JavaScript Object Notation) Ã© um formato de armazenamento e troca de dados que organiza
informaÃ§Ãµes de maneira estruturada e de fÃ¡cil leitura, tanto para humanos quanto para computadores. 

utiliza uma estrutura baseada em pares chaveâ€‘valor, semelhante a dicionÃ¡rios em Python ou objetos
em JavaScript,

API (Interface de ProgramaÃ§Ã£o de AplicaÃ§Ãµes) Ã© um conjunto de
regras e definiÃ§Ãµes que permite que diferentes sistemas e programas se
comuniquem entre si

#1.2 AnÃ¡lise de complexidade: introduÃ§Ã£o Ã  notaÃ§Ã£o Bigâ€‘O e Ã  anÃ¡lise
de eficiÃªncia

auxilia na tomada de decisÃµes sobre qual estratÃ©gia de implementaÃ§Ã£o Ã© mais adequada
para problemas que demandam alto desempenho ou lidam com grandes quantidades de dados


o comportamento assintÃ³tico refereâ€‘se Ã  forma como uma funÃ§Ã£o se comporta quando seu
parÃ¢metro tende ao infinito.


algoritmos => desejaâ€‘se saber como o tempo de execuÃ§Ã£o
(ou uso de memÃ³ria) varia em funÃ§Ã£o do tamanho da entrada, denotado com frequÃªncia por ğ‘›.

interessa mais a taxa de crescimento desses recursos Ã  medida que ğ‘› aumenta

o Bigâ€‘O Ã© a forma mais amplamente utilizada para descrever limites superiores de crescimento

exemplo: algoritmo ğ´ tem complexidade ğ‘‚(ğ‘“(ğ‘›)) significa que, para entradas
suficientemente grandes, o tempo de execuÃ§Ã£o de ğ´ nÃ£o cresce mais rÃ¡pido do que uma funÃ§Ã£o
constante vezes ğ‘“(ğ‘›)

 Se a sala tem 10 alunos, vocÃª faz 10 verificaÃ§Ãµes; se tem 100, faz 100
verificaÃ§Ãµes e assim por diante. Esse Ã© um exemplo de comportamento linear: conforme o nÃºmero de
alunos ğ‘› cresce, o trabalho sobe de forma proporcional e por isso dizemos que a tarefa estÃ¡ em ğ‘‚(ğ‘›).
Usando a definiÃ§Ã£o de Bigâ€‘O:
â€¢ ğ´(ğ‘›) Ã© o tempo para conferir todas as assinaturas.
â€¢ ğ‘“(ğ‘›) pode ser simplesmente n

execuÃ§Ã£o constante, o que significa que nÃ£o sofrem variaÃ§Ã£o
perceptÃ­vel Ã  medida que o tamanho da entrada cresce. SÃ£o classificados como 0(1). Um exemplo tÃ­pico
desse comportamento Ã© o acesso a um elemento especÃ­fico de um array (ou lista) por Ã­ndice: teoricamente,
consideraâ€‘se que buscar o valor em uma posiÃ§Ã£o jÃ¡ conhecida tem custo fixo, independentemente de
quantos elementos existem ao todo.

m algoritmos cujo tempo de execuÃ§Ã£o Ã© logarÃ­tmico, especialmente quando
o tamanho do problema Ã© reduzido pela metade (ou por um fator constante) a cada passo. A busca
binÃ¡ria em uma lista ordenada Ã© um exemplo clÃ¡ssico: a cada comparaÃ§Ã£o, descartaâ€‘se metade dos
elementos, o que faz a quantidade de passos crescer de forma proporcional a log  


 ğ‘‚(ğ‘› log ğ‘›), costuma-se dizer que ele Ã©
linearâ€‘logarÃ­tmico (Merge Sort
e Quick Sort (na mÃ©dia).)


ğ‘‚(ğ‘›2). Isso Ã© frequente em
algoritmos que utilizam laÃ§os aninhados, como Bubble Sort e Insertion Sort, em que para cada elemento
da lista Ã© preciso percorrer novamente toda a lista (ou uma fraÃ§Ã£o significativa dela).


ğ‘‚(ğ‘›3
), que surge em algoritmos
com tripla aninhada de laÃ§os, por exemplo, em mÃ©todos bÃ¡sicos de multiplicaÃ§Ã£o de matrizes. JÃ¡ ğ‘‚(2ğ‘›)
Ã© frequente em algoritmos de forÃ§a bruta, que testam todas as combinaÃ§Ãµes possÃ­veis para resolver um
problema de decisÃ£o

 ğ‘‚(ğ‘›!)  => caixeiro viajante


No uso prÃ¡tico, nem sempre o algoritmo assintoticamente mais rÃ¡pido Ã© o mais indicado. Para
entradas pequenas, mÃ©todos ğ‘‚(ğ‘›2
) podem superar outros ğ‘‚(ğ‘› log ğ‘›) devido a fatores como constantes
menores de tempo ou melhor uso de cache. Ã‰ por isso que engenheiros e cientistas da computaÃ§Ã£o
realizam nÃ£o apenas anÃ¡lise teÃ³rica, mas testes empÃ­ricos (microbenchmarks) para embasar suas
decisÃµes. 


Bigâ€‘O Ã© uma forma de medir e comparar a eficiÃªncia de algoritmos ao analisar
como o tempo de execuÃ§Ã£o (ou uso de memÃ³ria) cresce conforme aumenta o tamanho da entrada

2 ESTRUTURAS DE DADOS LINEARES

organizam os elementos em
uma sequÃªncia ordenada, na qual cada item possui um predecessor e um sucessor (exceto o primeiro e
o Ãºltimo). 
elementos sÃ£o acessados de maneira sequencial, respeitando
a ordem na qual foram inseridos. Diferentemente das estruturas nÃ£o lineares, como Ã¡rvores e grafos,
que permitem mÃºltiplas conexÃµes entre os elementos, as estruturas lineares mantÃªm uma relaÃ§Ã£o direta
entre os itens, o que facilita a manipulaÃ§Ã£o e o processamento dos dados.


permite a realizaÃ§Ã£o de operaÃ§Ãµes como pesquisa, inserÃ§Ã£o e remoÃ§Ã£o
com base na posiÃ§Ã£o dos elementos. Em listas e arrays, por exemplo, o acesso a um item pode ser feito
por meio de um Ã­ndice numÃ©rico, garantindo eficiÃªncia quando a posiÃ§Ã£o do elemento Ã© conhecida.
No entanto, a inserÃ§Ã£o e a remoÃ§Ã£o em determinadas posiÃ§Ãµes podem exigir deslocamentos de outros
elementos, o que impacta o desempenho dependendo da implementaÃ§Ã£o utilizada.


pilhas e filas sÃ£o classificadas como estruturas lineares porque
seguem uma ordem especÃ­fica de inserÃ§Ã£o e remoÃ§Ã£o.

LIFO (Last In, First Out) para pilhas e FIFO (First In, First Out) para listas

Quando hÃ¡ necessidade de relacionamentos hierÃ¡rquicos entre elementos
ou mÃºltiplas conexÃµes, como acontece em Ã¡rvores e grafos, as estruturas nÃ£o lineares tornamâ€‘se mais
apropriadas. Contudo, para armazenar e processar dados de forma sequencial, as estruturas lineares
continuam sendo uma das abordagens mais eficientes e amplamente utilizadas na computaÃ§Ã£o.

Listas sÃ£o adequadas para armazenamento genÃ©rico de elementos
heterogÃªneos, enquanto arrays sÃ£o preferÃ­veis para manipulaÃ§Ã£o eficiente de dados homogÃªneos.
Pilhas sÃ£o Ãºteis em problemas que exigem rastreamento de estados anteriores, como a execuÃ§Ã£o de
chamadas recursivas e o gerenciamento de histÃ³rico de navegaÃ§Ã£o. Filas, por sua vez, sÃ£o empregadas
em sistemas que necessitam de processamento sequencial de requisiÃ§Ãµes, como filas de impressÃ£o
e algoritmos de escalonamento

2.1 Listas e arrays: manipulaÃ§Ã£o, pesquisa, inserÃ§Ã£o e remoÃ§Ã£o

FunÃ§Ã£o DescriÃ§Ã£o
datetime.now() Retorna a data e a hora atuais do sistema
timedelta(seconds=n) Cria um intervalo de â€˜nâ€™ segundos, utilizado para manipulaÃ§Ã£o de datas e horÃ¡rios
sum(iterÃ¡vel) Calcula a soma dos elementos de um iterÃ¡vel (como listas e dicionÃ¡rios)
for elemento in iterÃ¡vel Itera sobre os elementos de um iterÃ¡vel, executando um bloco de cÃ³digo para cada item
dicionario[chave] Acessa o valor correspondente a uma chave dentro de um dicionÃ¡rio
dicionario[â€˜chaveâ€™] = valor Atribui um valor a uma chave especÃ­fica dentro de um dicionÃ¡rio

range(inÃ­cio, fim)
Gera uma sequÃªncia de nÃºmeros inteiros, incluindo o valor inicial e excluindo o valor final.
No cÃ³digo, Ã© usado implicitamente no for i in range(1, qtd_registros + 1)
para gerar os identificadores dos registros
random.choice(sequÃªncia) Retorna um elemento aleatÃ³rio de uma sequÃªncia, como uma lista. No cÃ³digo, Ã© usado
para escolher aleatoriamente um id_dispositivo
registros[-1] Acessa o Ãºltimo elemento da lista registros
timedelta(minutes=n) Cria um intervalo â€˜nâ€™ minutos, utilizado para cÃ¡lculos com datas e horas. JÃ¡ havia sido usada
com segundos, mas aqui hÃ¡ o uso especÃ­fico de minutos


pag 72








